<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="Tìm hiểu zk-SNARKs với rust!" /><meta property="og:locale" content="en" /><meta name="description" content="Zk-SNARKs là từ viết tắt của Zero-Knowledge Succinct Non-Interactive Argument of Knowledge. Zk-SNARK là một bằng chứng mật mã cho phép một bên chứng minh rằng họ sở hữu một số thông tin nhất định mà không tiết lộ thông tin đó. Bằng chứng này được thực hiện bằng cách sử dụng khóa bí mật được tạo trước khi giao dịch diễn ra. Nó được sử dụng như một phần của giao thức cho nhiều loại tiền điện tử như (ZCash)" /><meta property="og:description" content="Zk-SNARKs là từ viết tắt của Zero-Knowledge Succinct Non-Interactive Argument of Knowledge. Zk-SNARK là một bằng chứng mật mã cho phép một bên chứng minh rằng họ sở hữu một số thông tin nhất định mà không tiết lộ thông tin đó. Bằng chứng này được thực hiện bằng cách sử dụng khóa bí mật được tạo trước khi giao dịch diễn ra. Nó được sử dụng như một phần của giao thức cho nhiều loại tiền điện tử như (ZCash)" /><link rel="canonical" href="https://imduchuyyy.github.io/posts/zk-SNARKs/" /><meta property="og:url" content="https://imduchuyyy.github.io/posts/zk-SNARKs/" /><meta property="og:site_name" content="imduchuyyy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-23T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Tìm hiểu zk-SNARKs với rust!" /><meta name="twitter:site" content="@imduchuyyy" /><meta name="google-site-verification" content="WjaSzRel73OVQ7YfleqYO87Nm4jrGcuP5hF7zwxRjJ4" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-08-19T11:07:13+08:00","datePublished":"2022-07-23T00:00:00+08:00","description":"Zk-SNARKs là từ viết tắt của Zero-Knowledge Succinct Non-Interactive Argument of Knowledge. Zk-SNARK là một bằng chứng mật mã cho phép một bên chứng minh rằng họ sở hữu một số thông tin nhất định mà không tiết lộ thông tin đó. Bằng chứng này được thực hiện bằng cách sử dụng khóa bí mật được tạo trước khi giao dịch diễn ra. Nó được sử dụng như một phần của giao thức cho nhiều loại tiền điện tử như (ZCash)","headline":"Tìm hiểu zk-SNARKs với rust!","mainEntityOfPage":{"@type":"WebPage","@id":"https://imduchuyyy.github.io/posts/zk-SNARKs/"},"url":"https://imduchuyyy.github.io/posts/zk-SNARKs/"}</script><title>Tìm hiểu zk-SNARKs với rust! | imduchuyyy</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="imduchuyyy"><meta name="application-name" content="imduchuyyy"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://euc.li/imduchuyyy.eth" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">imduchuyyy</a></div><div class="site-subtitle font-italic">Huy's home is on the internet.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/imduchuyyy" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/imduchuyyy" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['imduchuyyy','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Tìm hiểu zk-SNARKs với rust!</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Tìm hiểu zk-SNARKs với rust!</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> imduchuyyy </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Jul 23, 2022, 12:00 AM +0800" >Jul 23, 2022<i class="unloaded">2022-07-23T00:00:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Aug 19, 2023, 10:07 AM +0700" >Aug 19, 2023<i class="unloaded">2023-08-19T11:07:13+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1821 words">10 min read</span></div></div><div class="post-content"><p>Zk-SNARKs là từ viết tắt của <code class="language-plaintext highlighter-rouge">Zero-Knowledge Succinct Non-Interactive Argument of Knowledge</code>. Zk-SNARK là một bằng chứng mật mã cho phép một bên chứng minh rằng họ sở hữu một số thông tin nhất định mà không tiết lộ thông tin đó. Bằng chứng này được thực hiện bằng cách sử dụng khóa bí mật được tạo trước khi giao dịch diễn ra. Nó được sử dụng như một phần của giao thức cho nhiều loại tiền điện tử như (<a href="https://z.cash/">ZCash</a>)</p><blockquote><p>zk-SNARKs is Zero-Knowledge proof protocol used in encryption, and is and acronym that stands for “Zero-Knowledge Succinct Non-Interactive Argument of Knowledge”.</p></blockquote><h1 id="hiểu-về-zk-snarks">Hiểu về zk-SNARKs</h1><p>Zk-SNARKs phát triển dựa trên thuật toán gốc <code class="language-plaintext highlighter-rouge">zero-knowledge proof</code>:</p><p><code class="language-plaintext highlighter-rouge">Zero-knowledge proof</code> (zk) là một loại thuật toán cho phép một bên (the prover) chứng minh với bên khác (the verifier) rằng một tuyên bố là đúng, mà không tiết lộ bất kỳ thông tin nào vượt quá giá trị của tuyên bố đó. Ví dụ, với <b>hàm băm của một số ngẫu nhiên</b>, prover có thể thuyết phục verifier rằng thực sự tồn tại một số với giá trị băm này, mà không tiết lộ nó là gì.</p><p>Mục tiêu của <code class="language-plaintext highlighter-rouge">zero-knowledge proofs</code> là để verifier có thể tự thuyết phục mình rằng prover sở hữu kiến thức về một tham số bí mật, được gọi là <code class="language-plaintext highlighter-rouge">witness</code>, đáp ứng một số mối quan hệ, mà không tiết lộ <code class="language-plaintext highlighter-rouge">witness</code> cho verifier hoặc bất kỳ ai khác.</p><p>Trong từ viết tắt SNARK, <code class="language-plaintext highlighter-rouge">succinct</code> có nghĩa là những bằng chứng này có kích thước nhỏ hơn và có thể nhanh chóng được xác minh. <code class="language-plaintext highlighter-rouge">Non-interactive</code> có nghĩa là có rất ít hoặc không có sự tương tác giữa prover và verifier. Các phiên bản cũ hơn của zero-knowledge protocols thường yêu cầu prover và verifier giao tiếp qua lại và do đó, được coi là . Nhưng trong các cấu trúc <code class="language-plaintext highlighter-rouge">non-interactive</code>, prover và verifier chỉ phải trao đổi một bằng chứng. Chuyển sang phần <code class="language-plaintext highlighter-rouge">Arguments of Knowledge</code> của từ viết tắt. zk-SNARK được coi là hợp lý về mặt tính toán, có nghĩa là một prover không trung thực có rất ít khả năng gian lận thành công hệ thống mà không thực sự có dữ liệu về witness để hỗ trợ chứng minh của họ. Tính chất này được gọi là tính hợp lý và giả định rằng prover có khả năng tính toán hạn chế.</p><p>Về mặt lý thuyết, một prover có đủ sức mạnh tính toán có thể tạo ra các bằng chứng giả, và đây là một trong những lý do khiến máy tính lượng tử được nhiều người coi là mối đe dọa đối với zk-SNARK (và các hệ thống blockchain).</p><p>Chúng ta có thể nghĩ về điều này một cách cụ thể hơn là có một hàm, ký hiệu là C, lấy hai đầu vào: C (x, w). Đầu vào x là đầu vào công khai và w là đầu vào của <code class="language-plaintext highlighter-rouge">witness</code>. Đầu ra của chương trình là boolean, tức là true hoặc false. Mục tiêu sau đó được đưa ra một đầu vào công khai cụ thể x, chứng minh rằng prover biết <code class="language-plaintext highlighter-rouge">witness</code> w sao cho C (x, w) == true.</p><p><code class="language-plaintext highlighter-rouge">Zero-knowledge proof</code> có thể xác minh nhanh chóng và thường chiếm ít dữ liệu hơn nhiều so với một giao dịch Bitcoin tiêu chuẩn. Điều này mở ra một con đường cho công nghệ zk-SNARK được sử dụng như một giải pháp bảo mật và khả năng mở rộng.</p><p>Trên thế giới hiện nay đã có rất nhiều implement của zk-SNARKs, các bạn có thể tìm hiểu qua:</p><ul><li><a herf="https://github.com/microsoft/Spartan">Spartan của ông lớn Microsoft</a><li><a herf="https://github.com/zkcrypto/bellman">Bellman</a><li>…</ul><h1 id="cách-thức-hoạt-động-của-zk-snarks">Cách thức hoạt động của zk-SNARKs</h1><p>Zk-SNARKs bao gồm 3 thuật toán khác nhau: G, P and V</p><ol><li><p>G algorithm: G (Key generation) nhận vào input “lambda” (phải được giữ bí mật về input lambda) và chương trình C. Sau đó, G tiến hành tạo ra 2 public key, 1 khoá dành cho prover (pk) và một khoá dành cho verifier (vk). Các khoá này đều công khai cho tất cả các bên tham gia</p><li>P algorithm: P dành cho prover nhận vào 3 tham số đầu vào:<ul><li>pk: khoá dành cho prover (generate bằng G)<li>x: Tham số ngẫu nhiên public bởi các bên<li>w: private statament prover muốn chứng minh họ biết nhưng không muốn tiết lộ w</ul><p>Thuật toán P tạo ra một bằng chứng <code class="language-plaintext highlighter-rouge">prf = P(pk, x, w)</code></p><li>V algorithm: V nhận vào 3 input và cơ bản trả về 1 trá trị boolean.<ul><li>vk: Khoá dành cho verifier (generate bằng G)<li>x: Tham số tạo bởi P<li>prf: Proof tạo bởi prover</ul><p><code class="language-plaintext highlighter-rouge">boolean a = V(vk, x, prf)</code></p></ol><p>Một biết boolean có 2 lựa chọn, TRUE có nghĩa là bằng chứng cho P tạo ra là đúng, FALSE là ngược lại.</p><p>Về tham số lambda và chương trình C:</p><ul><li>Tham số Lambda phải được giữ bí mật vì bất kì ai có được tham số lambda đều có thể tạo ra <b>prf</b> giả mạo<li>Về cơ bản, hàm C nhận 2 giá trị đầu vào, giá trị công khai x và tham số bí mật w, Thường x sẽ được chọn là giá trị hash của w, <code class="language-plaintext highlighter-rouge">x = H(w)</code> và hàm C được thiết kế như sau:</ul><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="bp">...</span>
    <span class="k">return</span> <span class="nf">sha256</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span>
</pre></table></code></div></div><h1 id="example-với-ngôn-ngữ-rust">Example với ngôn ngữ Rust</h1><h2 id="giới-thiệu-về-rust">Giới thiệu về Rust</h2><p>Rust là ngôn ngữ lập trình được tạo ra vào năm 2006 bởi Graydon Hoare như một dự án phụ khi đang là developer tại Mozilla. Rust pha trộn hiệu suất của các ngôn ngữ như C ++ với cú pháp thân thiện hơn, tập trung vào code an toàn và được thiết kế tốt giúp đơn giản hóa việc phát triển</p><p>Nói một cách đơn giản, mình thấy Rust là ngôn ngữ lập trình cấp thấp (low level), định kiểu tĩnh (statically typed), khá là đa dụng (multi-paradigm), phù hợp với các ứng dụng tập trung vào sự an toàn và hiệu suất.</p><h2 id="giới-thiệu-về-bellman">Giới thiệu về bellman</h2><p><a href="https://github.com/zcash/librustzcash/tree/master/bellman">Bellman</a> là một thư viện phần mềm zk-SNARK được phát triển bởi nhóm <a href="https://z.cash/">Zcash</a> bằng ngôn ngữ Rust, thực hiện thuật toán Groth16.</p><p>Quy trình tổng thể của bellman:</p><p><img data-proofer-ignore data-src="https://res.cloudinary.com/duchuy/image/upload/v1658896370/nottheblog/1_CXpf6f27J7kx83C_nRtF-g_sfprc7.png" /></p><p>Quá trình tổng thể có thể được chia thành các bước sau:</p><ol><li>Flatten bài toán đa thức và xây dựng circuit tương ứng. Bước này được thực hiện bởi upper-level application<li>Tạo R1CS (Rank 1 Constraint System) theo circuit ở bước 1<li>Chuyển đổi R1CS (Rank 1 Constraint System) sang QAP (Quadratic Arithmetic Program). Phương pháp truyền thống là sử dụng phép <a href="https://en.wikipedia.org/wiki/Lagrange_polynomial">nội suy Lagrange</a>, nhưng để giảm độ phức tạp tính toán, nó có thể được thực hiện bằng <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">Fast Fourier Transform</a>.<li>Setup các tham chiếu của QAP, đó là CRS (Common Reference Strings)<li>Tạo proof dựa trên CRS và input của prover<li>Verifier verify proof</ol><h2 id="let-code-with-terry-">Let Code With Terry =))</h2><p>Trong ví dụ lần này, mình sẽ demo một bài toán đơn giản:</p><blockquote><p>Lin và Terry biết một giá trị <code class="language-plaintext highlighter-rouge">c</code> và Lin muốn chứng minh với Terry “Lin biết 2 số một giá trị <code class="language-plaintext highlighter-rouge">y</code> sao cho <code class="language-plaintext highlighter-rouge">hash(y) = c</code> mà không làm lộ giá trị của <code class="language-plaintext highlighter-rouge">y</code>”</p></blockquote><h3 id="setup-project">Setup project</h3><p>Tạo project</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">mkdir </span>bellman-example
<span class="nb">cd </span>bellman-example
</pre></table></code></div></div><p>Init cargo project</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cargo init
</pre></table></code></div></div><p>Add bellman dependencies vào file Cargo.toml</p><p>File <code class="language-plaintext highlighter-rouge">Cargo.toml</code> sẽ trông giống như thế này:</p><div class="language-toml highlighter-rouge"><div class="code-header"> <span text-data=" TOML "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nn">[package]</span>
<span class="py">authors</span> <span class="p">=</span> <span class="p">[</span><span class="s">"Terry"</span><span class="p">]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"bellman-example"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="c"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

<span class="nn">[dependencies]</span>
<span class="py">bellman</span> <span class="p">=</span> <span class="s">"0.13.1"</span>
</pre></table></code></div></div><p>Build thử và chạy project</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cargo build <span class="o">&amp;&amp;</span> ./target/debug/bellman-example
</pre></table></code></div></div><p>Chúng ta đã hoàn thành setup rust project đơn giản.</p><h3 id="setup-bài-toán">Setup bài toán</h3><p>Bellman cung cấp cho chúng ta <code class="language-plaintext highlighter-rouge">Circuit</code> trait, chúng tá có thể sử dụng nó để synthesize các ràng buộc của bài toán trên</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span text-data=" Rust "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cd">/// Implement sha256(hash) function. Input and output are in little-endian bit order.</span>
<span class="k">fn</span> <span class="n">impl_sha256</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">:</span> <span class="n">PrimeField</span><span class="p">,</span> <span class="n">CS</span><span class="p">:</span> <span class="n">ConstraintSystem</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;&gt;</span> <span class="p">(</span>
    <span class="k">mut</span> <span class="n">cs</span><span class="p">:</span> <span class="n">CS</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Boolean</span><span class="p">]</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SynthesisError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">input</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">c</span><span class="p">|</span> <span class="n">c</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.rev</span><span class="p">())</span><span class="nf">.flatten</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="nf">sha256</span><span class="p">(</span><span class="n">cs</span><span class="nf">.namespace</span><span class="p">(||</span> <span class="s">"SHA-256(input)"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="nf">.chunks</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">c</span><span class="p">|</span> <span class="n">c</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.rev</span><span class="p">())</span><span class="nf">.flatten</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.collect</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">OurProblem</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">80</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="p">:</span> <span class="n">PrimeField</span><span class="o">&gt;</span> <span class="n">Circuit</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">OurProblem</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">synthesize</span><span class="o">&lt;</span><span class="n">CS</span><span class="p">:</span> <span class="n">ConstraintSystem</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">CS</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">SynthesisError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Trong hàm <code class="language-plaintext highlighter-rouge">synthesize</code>, chúng ta define bài toán theo dạng <a href="https://en.wikipedia.org/wiki/Constraint_programming">Constraint programming</a> và alloc giá trị vào các biến được define ở <code class="language-plaintext highlighter-rouge">OurProblem</code> struct</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span text-data=" Rust "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="n">synthesize</span><span class="o">&lt;</span><span class="n">CS</span><span class="p">:</span> <span class="n">ConstraintSystem</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">CS</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">SynthesisError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">bit_values</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.value</span> <span class="p">{</span>
        <span class="n">value</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">byte</span><span class="p">|</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">8</span><span class="p">)</span><span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">i</span><span class="p">|</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1u8</span> <span class="o">==</span> <span class="mi">1u8</span><span class="p">))</span><span class="nf">.flatten</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="nf">.collect</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">vec!</span><span class="p">[</span><span class="nb">None</span><span class="p">;</span> <span class="mi">80</span> <span class="o">*</span> <span class="mi">8</span><span class="p">]</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">pre_bit</span> <span class="o">=</span> <span class="n">bit_values</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="p">{</span>
        <span class="nn">AllocatedBit</span><span class="p">::</span><span class="nf">alloc</span><span class="p">(</span><span class="n">cs</span><span class="nf">.namespace</span><span class="p">(||</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"Pre bit {}"</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">})</span><span class="nf">.map</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span><span class="nf">.map</span><span class="p">(</span><span class="nn">Boolean</span><span class="p">::</span><span class="n">from</span><span class="p">))</span>
    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">hash</span> <span class="o">=</span> <span class="nf">impl_sha256</span><span class="p">(</span><span class="n">cs</span><span class="nf">.namespace</span><span class="p">(||</span> <span class="s">"SHA-256(value)"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">pre_bit</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nn">multipack</span><span class="p">::</span><span class="nf">pack_into_inputs</span><span class="p">(</span><span class="n">cs</span><span class="nf">.namespace</span><span class="p">(||</span> <span class="s">"pack hash"</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">)</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="tạo-random-key">Tạo random key</h3><p>Tạo bộ <code class="language-plaintext highlighter-rouge">pk</code> và <code class="language-plaintext highlighter-rouge">pvk</code>, bộ key này sẽ được công khai và chia sẻ giữa Lin và Terry:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span text-data=" Rust "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">problem</span><span class="p">::</span><span class="n">OurProblem</span> <span class="p">{</span> <span class="n">value</span><span class="p">:</span> <span class="nb">None</span> <span class="p">};</span>

    <span class="nn">generate_random_parameters</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Bls12</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">OsRng</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"Prepare key..."</span><span class="p">);</span>
<span class="k">let</span> <span class="n">pvk</span> <span class="o">=</span> <span class="nf">prepare_verifying_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="py">.vk</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="tạo-proofs">Tạo proofs</h3><p>Tạo proof với hidden input. Ở đây mình sẽ lấy ví dụ giá trị <code class="language-plaintext highlighter-rouge">y</code> của Lin là <code class="language-plaintext highlighter-rouge">[40; 80]</code>. Lin gửi <code class="language-plaintext highlighter-rouge">inputs</code> + <code class="language-plaintext highlighter-rouge">proof</code> cho Terry với tuyên bố <code class="language-plaintext highlighter-rouge">Lin biết giá trị y sao cho hash(y) = x</code></p><div class="language-rust highlighter-rouge"><div class="code-header"> <span text-data=" Rust "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">println!</span><span class="p">(</span><span class="s">"Prepare input..."</span><span class="p">);</span>
<span class="k">let</span> <span class="n">hidden_value</span> <span class="o">=</span> <span class="p">[</span><span class="mi">40</span><span class="p">;</span> <span class="mi">80</span><span class="p">];</span>
<span class="k">let</span> <span class="n">hash_bit</span> <span class="o">=</span> <span class="nf">bytes_to_bits_le</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">Sha256</span><span class="p">::</span><span class="nf">digest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hidden_value</span><span class="p">));</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">compute_multipacking</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash_bit</span><span class="p">);</span>

<span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">problem</span><span class="p">::</span><span class="n">OurProblem</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">hidden_value</span><span class="p">),</span>
<span class="p">};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"Create proof..."</span><span class="p">);</span>
<span class="k">let</span> <span class="n">proof</span> <span class="o">=</span> <span class="nf">create_random_proof</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">params</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">OsRng</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
</pre></table></code></div></div><h3 id="verify-proof">Verify proof</h3><p>Terry có thể verify tuyên bố của Lin là đúng ở bước <code class="language-plaintext highlighter-rouge">Tạo proofs</code> bằng cách tự xác thực proof mà không cần liên hệ với Lin đây là điểm <code class="language-plaintext highlighter-rouge">non-interactive</code> trong zk-SNARKs:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span text-data=" Rust "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">println!</span><span class="p">(</span><span class="s">"Verify proof..."</span><span class="p">);</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">verify_proof</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proof</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {}"</span><span class="p">,</span> <span class="n">result</span><span class="nf">.is_ok</span><span class="p">());</span>
</pre></table></code></div></div><div class="language-sh highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Verify proof...
Result: <span class="nb">true</span>
</pre></table></code></div></div><p>Toàn bộ source code của example mình sẽ để <a target="_blank" href="https://github.com/bui-duc-huy/bellman-example">ở đây</a>. Với bất kỳ thắc mắc các bạn có thể open issue ở repo, mình sẽ trả lời nếu mình biết :v.</p><h1 id="conclusion">Conclusion</h1><p>Như vậy qua bài viết cũng đã phần nào giới thiệu sơ lược về <code class="language-plaintext highlighter-rouge">zk-SNARKs</code>. Theo đánh giá cá nhân của mình, mình nghĩ <code class="language-plaintext highlighter-rouge">zk-SNARKs</code> là một công nghệ khá là thú vị và đáng học hỏi cho các bạn tìm hiểu về thuật toán mã hoá. Ứng dụng của nó cũng đã được chứng minh ở các dự án về blockchain lớn có thể kể tên như <a target="_blank" href="https://tornado.cash/">Tornado Cash</a>, <a target="_blank" href="https://z.cash/">Z Cash</a></p><h1 id="references">References</h1><ol><li><a target="_blank" href="https://github.com/arcalinea/bellman-examples">Bellman example</a><li><a target="_blank" href="https://starli.medium.com/zkp-deep-into-bellman-library-9b1bf52cb1a6">ZKP — Deep into Bellman Library</a><li><a target="_blank" href="https://www.investopedia.com/terms/z/zksnark.asp">What Is zk-SNARK?</a></ol></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Tìm hiểu zk-SNARKs với rust! - imduchuyyy&url=https://imduchuyyy.github.io/posts/zk-SNARKs/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Tìm hiểu zk-SNARKs với rust! - imduchuyyy&u=https://imduchuyyy.github.io/posts/zk-SNARKs/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Tìm hiểu zk-SNARKs với rust! - imduchuyyy&url=https://imduchuyyy.github.io/posts/zk-SNARKs/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/what-is-liquid-staking/">Why we need liquid staking?</a><li><a href="/posts/explain-mpc-by-math-concepts/">[Research] Explain MPC by basic math concepts</a><li><a href="/posts/smart-contract-best-practice-3/">Smart contract best practice 3</a><li><a href="/posts/block-gas-limit-attack/">Block gas limit attack</a><li><a href="/posts/varieties-of-proof-of-stake/">Varieties of Proof of Stake!</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/what-is-liquid-staking/"><div class="card-body"> <span class="timeago small" >Sep 3<i class="unloaded">2024-09-03T18:21:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Why we need liquid staking?</h3><div class="text-muted small"><p> Heyyy, trong một ngày mưa gió, ngồi ở quán cafe ngắm đường phố, cũng rảnh rỗi nên viết bài chia sẽ 1 xíu với mọi người về Liquid Staking nhen. Topic liquid staking thực sự cũng không mới, chỉ cần l...</p></div></div></a></div><div class="card"> <a href="/posts/how-to-send-a-sponsor-transaction/"><div class="card-body"> <span class="timeago small" >Aug 19<i class="unloaded">2024-08-19T14:51:30+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How to send a sponsor transactions?</h3><div class="text-muted small"><p> GM GM mọi người, hôm nay mình cùng nhau đi tìm hiểu có cách nào để giải quyết vấn để sponsor transaction trên blockchain không?. Có cách nào để giúp trải nghiệm của người dùng mượt mà hơn ví dụ như...</p></div></div></a></div><div class="card"> <a href="/posts/back-to-blogging/"><div class="card-body"> <span class="timeago small" >Aug 14<i class="unloaded">2024-08-14T12:00:30+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Back To Blogging</h3><div class="text-muted small"><p> GM GM, Đã hơn 8 tháng rồi mình không quay lại viết blog, đến mức mà domain nottheblog hết hạn luôn rồi =)). Check lại thì bài gần nhất đã từ tháng 12 2023. Thật ra là mình vẫn có viết, viết trên ch...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/tokenomics/" class="btn btn-outline-primary" prompt="Older"><p>Everything About Tokenomics!</p></a> <a href="/posts/explain-mpc-by-math-concepts/" class="btn btn-outline-primary" prompt="Newer"><p>[Research] Explain MPC by basic math concepts</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/imduchuyyy">imduchuyyy</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-4KTN6TMKWE"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-4KTN6TMKWE'); }); </script>
